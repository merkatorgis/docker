#!/bin/bash

export MSYS_NO_PATHCONV=1
docker4gis=$(basename "$0")
log_path=$docker4gis.log
version_development=development

log=/dev/null
if [ "$1" = trace ]; then
    # Trace all shell commands and activate tee'ing all output to a log file.
    shift 1
    log=$log_path
    set -x
    export SHELLOPTS
fi

# The whole script is between {} so that all output can bee tee'd.
{
    action=$1
    shift 1

    default_docker4gis_command="npx --yes $docker4gis@latest"
    docker4gis_command=${ALIAS_NAME:-$default_docker4gis_command}

    INSTALLED=
    dg_dir=$(dirname "$0")
    if [ "$(basename "$dg_dir")" = '.bin' ]; then
        INSTALLED=true
        dg_dir="$dg_dir"/../$docker4gis
    fi
    dg_dir=$(realpath "$dg_dir")
    DOCKER_BASE="$dg_dir"/base

    package_json() {
        [ -f package.json ] || echo '{
  "version": "0.0.0"
}' >package.json
        echo '*.log' >>.gitignore
    }

    pipeline() {
        local main=$1

        write() {
            local file=$1
            local steps=$2
            local trigger=$main
            local pr=none
            [ "$file" = "$build_validation" ] && {
                trigger=none
                pr=$main
            }

            login() {
                if [ "$file" = "$continuous_integration" ]; then
                    echo
                    if [ "$action" = 'base-component' ]; then
                        git_repo=$(basename "$(realpath .)")
                        echo "- script: |"
                        echo "    git remote set-url origin https://merkatorgis:\$(GITHUB_PASSWORD)@github.com/merkatorgis/$git_repo.git"
                    else
                        echo "- checkout: self"
                        echo "  persistCredentials: 'true'"
                    fi
                    echo "  displayName: 'git login'"
                fi
                if [ "$file" = "$continuous_integration" ] || [ "$action" = 'init' ]; then
                    echo
                    echo "- script: |"
                    echo "    echo '\$(DOCKER_PASSWORD)' | docker login -u=$DOCKER_USER --password-stdin $DOCKER_REGISTRY"
                    echo "  displayName: 'docker login'"
                    echo '#'
                fi
            }

            echo "trigger:
- $trigger

pr:
- $pr

pool:
  vmImage: ubuntu-latest

steps:$(login)
$steps" >"$file"
        }

        local build_validation=azure-pipeline-build-validation.yml
        write "$build_validation" "- script: |
    $default_docker4gis_command build
  displayName: '$docker4gis build'"

        local continuous_integration=azure-pipeline-continuous-integration.yml
        write "$continuous_integration" "- script: |
    git config --global user.email 'pipeline@azure.com'
    git config --global user.name 'Azure Pipeline'
  displayName: 'git config'

- script: |
    git checkout -b $main
    git push --set-upstream origin $main
  displayName: 'git undo detached state'
  
- script: |
    $default_docker4gis_command push
  displayName: '$docker4gis push'"
    }

    version() {
        if [ "$INSTALLED" ]; then
            node --print "require('$DOCKER_BASE/../package.json').version"
        else
            echo "$version_development"
        fi
    }

    dotenv() {
        local flag=$1
        local file=${2:-.env}

        [ "$flag" = 'export' ] && set -a
        # shellcheck source=/dev/null
        . "$file"
        [ "$flag" = 'export' ] && set +a

        [ "$flag" = 'forgiving' ] || [ "$DOCKER4GIS_VERSION" ] || {
            echo "Current directory not recognised as a $docker4gis package or component."
            exit 1
        }
    }

    # shellcheck disable=SC2317  # It's correct that the function is never called in this script.
    self() {
        # Command given to the "all" action may use `self` to run docker4gis actions.
        "$0" "$@"
    }

    just_help=
    [ "$1" = help ] && just_help=true
    [ "$action" = help ] && {
        just_help=true
        action=$1
        shift 1
    }
    help() {
        [ "$just_help" ] || return 0
        local help_text=$1
        echo "$help_text"
        exit
    }

    case "$action" in

    init)
        help "Initialise a new $docker4gis application in the current directory.
Do this somewhere where you can later create sibbling directories for the
application's components (using \`$docker4gis_command component\`)."

        DOCKER_REGISTRY=$1
        DOCKER_USER=$2

        [ "$DOCKER_REGISTRY" ] && shift 1
        [ "$DOCKER_REGISTRY" ] || read -rp \
            "Enter the Docker registry (default is the Docker Hub; enter m for docker.merkator.com : " \
            DOCKER_REGISTRY
        [ "$DOCKER_REGISTRY" = 'm' ] && DOCKER_REGISTRY=docker.merkator.com
        [ "$DOCKER_REGISTRY" ] || DOCKER_REGISTRY=docker.io

        [ "$DOCKER_USER" ] && shift 1
        suggestion=$(basename "$(realpath ..)")
        [ "$DOCKER_USER" ] || read -rp \
            "Enter the application's name (the \"user\" in the Docker registry; default is $suggestion) : " \
            DOCKER_USER
        [ "$DOCKER_USER" ] || DOCKER_USER="$suggestion"

        echo "DOCKER4GIS_VERSION=$(version)
DOCKER_REGISTRY=$DOCKER_REGISTRY
DOCKER_USER=$DOCKER_USER
DOCKER_REPO=package
DEBUG=false
PROXY_HOST=
PROXY_PORT=
PROXY_PORT_HTTP=
SECRET=
API=
AUTH_PATH=
APP=
HOMEDEST=
TZ=
PGHOST=
PGHOSTADDR=
PGPORT=
PGDATABASE=
PGUSER=
PGPASSWORD=
POSTGRES_LOG_STATEMENT=
# POSTGRES_LOG_STATEMENT=ddl
# POSTGRES_LOG_STATEMENT=all
MYSQL_HOST=
MYSQL_DATABASE=
MYSQL_ROOT_PASSWORD=
POSTFIX_DESTINATION=
POSTFIX_DOMAIN=" >>.env

        mkdir -p components
        echo "$DOCKER_USER".log >>.gitignore

        package_json
        pipeline main
        bash -i "$0" alias TEST
        ;;

    component | base-component | template)
        [ "$action" = component ] && help "Initialise a new $docker4gis application component in the current directory.
Do this in a sibling directory of your application directory (where you ran
\`$docker4gis_command init\`)."

        [ "$action" = base-component ] && help "Initialise a new $docker4gis base component in the current directory.
Base components are the repositories in https://hub.docker.com/u/$docker4gis.
This action will render a skeleton that you can build upon. Get in touch with
to discuss publication."

        [ "$action" = template ] && help "When developing a $docker4gis base component, scaffold a client application in
the current directory, so that you can try your new base component. When you're
happy, you can copy the contents into the 'template' directory of your base
component."

        write_dotenv() {
            echo "DOCKER4GIS_VERSION=$DOCKER4GIS_VERSION
DOCKER_REGISTRY=$DOCKER_REGISTRY
DOCKER_USER=$DOCKER_USER
DOCKER_REPO=$repo" >>.env
        }

        replace_component() {
            search='{{COMPONENT}}'
            replace=$repo
            find . -type f -exec sed -i "s|$search|$replace|ig" {} \;
        }

        finish() {
            local message=${1:-"$action initialised âœ…"}
            local code=${2:-0}
            echo "$message"
            exit "$code"
        }

        error() {
            local message=${1:-error}
            local code=${2:-1}
            finish "$message" "$code"
        }

        package_json

        suggestion=$(basename "$(realpath "$PWD")")
        # Without a possible `docker4gis-` prefix.
        suggestion=${suggestion#"$docker4gis"-}
        # Up until a possible first `.` character (to support forked repos named
        # component.name.surname).
        suggestion=${suggestion%%.*}

        [ "$action" = base-component ] && {
            # Creating a generic docker4gis base component.
            repo=$1
            [ "$repo" ] || read -rp \
                "Enter the base component's name (the \"repository\" in the Docker registry; default is $suggestion) : " \
                repo
            [ "$repo" ] || repo=$suggestion
            DOCKER4GIS_VERSION=$(version)
            DOCKER_REGISTRY=docker.io
            DOCKER_USER=$docker4gis

            cp -r "$DOCKER_BASE"/template/. .
            replace_component

            write_dotenv
            pipeline main
            # And we're done!
            finish
        }

        # Creating a concrete application's component.

        # Load the package's environment values.
        for env_file in ../*/.env; do
            # Break when there's none.
            [ -f "$env_file" ] || break
            dotenv forgiving "$env_file"
            if [ "$DOCKER_REPO" = package ] && [ "$DOCKER4GIS_VERSION" ] && [ "$DOCKER_REGISTRY" ] && [ "$DOCKER_USER" ]; then
                inited=true
                break
            fi
        done

        [ "$inited" ] ||
            error "Package directory not foud; to create one, run $docker4gis_command init."

        [ "$1" ] || interactive=true
        repo=$1
        component=$2
        tag=$3
        template=$4

        [ "$repo" ] || read -rp \
            "Name the new component (default is $suggestion) : " repo
        [ "$repo" ] || repo=$suggestion

        write_dotenv

        suggestion=$repo
        [ "$repo" = api ] && suggestion=postgrest
        [ "$repo" = app ] && suggestion=angular
        [ "$repo" = dynamic ] && suggestion=serve
        component_question="Which $docker4gis base image to extend? e.g. proxy, or postgis (default is $suggestion"
        [ "$action" = template ] || component_question="$component_question, n for none"

        [ "$component" ] || read -rp \
            "$component_question) : " \
            component
        [ "$component" ] || component=$suggestion

        [ "$action" = template ] && {
            # Just scaffolding an inital setup for developing a template for a new
            # base component.
            cp -r "$DOCKER_BASE"/template/template/. .
        }

        [ "$component" = n ] && {
            # Creating a component _not_ extending a docker4gis base component.
            cp -r "$DOCKER_BASE"/template/. .
            rm -rf template
            pipeline main
        }

        [ "$action" = template ] || [ "$component" = n ] && {
            replace_component
            # And we're done!
            finish
        }

        # Creating a component extending a docker4gis base component.

        pipeline main

        [ "$interactive" ] && {
            [ "$tag" ] || read -rp \
                "Which base image tag to use? (default is latest) : " tag
        }
        [ "$tag" ] || tag=latest

        image=$docker4gis/$component:$tag
        docker image pull "$image" ||
            error "Image not found: $image"

        container=$(docker container create "$image") ||
            error "Failed to create container from image $image"

        docker container cp "$container":/template . ||
            error "$image doesn't seem a $docker4gis component"

        docker container rm "$container" >/dev/null
        if ! [ "$template" ]; then
            # Test if there are multiple templates, by checking the existence of the
            # '.default' file.
            default=./template/.default
            if [ -f "$default" ]; then
                default=$(cat "$default")
                # Override the default template if there's a template named just
                # like the repo itself.
                [ -d "./template/$repo" ] && default=$repo
                template=$default
                [ "$interactive" ] && {
                    choices=$(ls ./template)
                    choices=$(echo "$choices" | xargs)
                    read -rp \
                        "Enter the template name (one of: $choices - default is $default) : " \
                        template
                    [ "$template" ] || template=$default
                    ls ./template/"$template" >/dev/null 2>&1 ||
                        error "Template not found: $template"
                }
            fi
        fi
        cp -r ./template/"$template"/. .
        rm -rf ./template
        finish
        ;;

    build | run | br | push | test | stop | geoserver)
        [ "$action" = build ] && help "Build a new image for the application component in the current directory.
Or pass the name of a sibling directory to build that component there."

        [ "$action" = run ] && help "Run the application residing in one of the siblings of the current directory.
If a newer version of a component is found in a component directory, the
application directory is updated to run that newer version.
If a 'latest' version of a component image is found locally, and the version
in the component's package.json isn't newer than the version the application
had registered, then that 'latest' component version is run."

        [ "$action" = br ] && help "First build, then run. Can also br [COMPONENT] from a sibling directory."

        [ "$action" = push ] && help "Increment the component's version, build its image, push it to the Docker
registry, commit and push git changes.
Note that ideally, this is run by the Continuous Integration pipeline. If
that's configured, refrain from running \`push\` by hand."

        [ "$action" = test ] && help "Run the component's tests."

        [ "$action" = stop ] && help "Stop the application's containers.
Except the proxy container, since that may still serve other applications."

        [ "$action" = geoserver ] && help "Copy the GeoServer configuration files out of the running $DOCKER_USER-geoserver
container, to the geoserver component repository in the current directory."

        dotenv export

        # If not running an unpublished, local, in-development version of
        # docker4gis, switch to the version that the component scripts are
        # expecting. Otherwise, ignore the component's current DOCKER4GIS_VERSION,
        # and use the in-development version to see its effects.
        [ "$INSTALLED" ] && DOCKER_BASE=$(npx --yes "$docker4gis"@"$DOCKER4GIS_VERSION" base)
        [ "$INSTALLED" ] || DOCKER4GIS_VERSION=$version_development

        "$DOCKER_BASE/main.sh" . "$action" "$@"
        ;;

    "$docker4gis")
        help "Just echo '$docker4gis' to indicate that this is that program."

        echo "$docker4gis"
        ;;

    base)
        help "Echo the value of the DOCKER_BASE variable."

        echo "$DOCKER_BASE"
        ;;

    version)
        help "Echo the $docker4gis version."

        version
        ;;

    login)
        dotenv
        help "Log into the DOCKER_REGISTRY ($DOCKER_REGISTRY).
Usage: $docker4gis_command login [PASSWORD] [USER].
Without PASSWORD, you'll be asked to type it.
Default USER is the DOCKER_USER value ($DOCKER_USER)."

        password=${1:?"password parameter not set"}
        user=${2:-$DOCKER_USER}
        echo "$password" | docker login -u "$user" --password-stdin "$DOCKER_REGISTRY"
        ;;

    alias)
        help "Create a shell alias for \`$default_docker4gis_command\`.
Usage: $docker4gis_command alias [NAME]
Without NAME, you'll be asked to type one, or accept the default."

        # https://serverfault.com/a/146747
        [[ $- == *i* ]] && interactive=true
        [ "$interactive" ] || {
            # rerun this action with bash in interactive mode, so that aliases are
            # loaded
            bash -i "$0" alias "$@"
            exit 0
        }

        dg=dg

        test=$1
        [ "$test" = 'TEST' ] && {
            shift 1
            if [ "$("$dg" "$docker4gis" 2>/dev/null)" = "$docker4gis" ]; then
                exit 0
            else
                answer=
                read -rp "Create an alias for \`$default_docker4gis_command\`? [Yn] " answer
                [ "$answer" ] || answer=y
                if ! [ "$answer" = 'y' ] && ! [ "$answer" = 'Y' ]; then
                    exit 0
                fi
            fi
        }

        name=$1

        [ "$name" ] || read -rp "Enter the name for the alias (default is $dg) : " name
        [ "$name" ] || name=$dg

        command_type=$(type -t "$name" 2>/dev/null) && {
            if [ "$command_type" = "alias" ] && [ "$($name "$docker4gis")" = "$docker4gis" ]; then
                : # This name was already an alias for docker4gis; nothing to do.
            else
                echo "$name is occupied; choose another name"
                "$0" alias
            fi
            exit
        }

        echo "alias $name='ALIAS_NAME=$name $default_docker4gis_command'" >>~/.bashrc

        shopt -s expand_aliases
        # shellcheck source=/dev/null
        . ~/.bashrc
        ;;

    git-push)
        new_branch=${1:-"$docker4gis-changes"}
        remote_branch_info=$(git ls-remote --heads origin refs/heads/"$new_branch") &&
            if [ "$remote_branch_info" ]; then
                echo "Error: remote branch exists: $new_branch" >&2
                false
            fi &&
            current_branch=$(git rev-parse --abbrev-ref HEAD) &&
            git switch --create "$new_branch" &&
            git commit --all --message="$new_branch" &&
            git push --set-upstream origin "$new_branch" &&
            git switch "$current_branch" &&
            git branch --delete "$new_branch"
        ;;

    bump)
        help "In the current directory's component, bump $docker4gis to the latest version ($(version)).
Usage: $docker4gis_command bump [push].
With \`push\`, the change is committed in git in a new branch, that is pushed
to \`origin\`, ready to create a pull request. Locally, the new branch is
deleted after switching back to the current branch, ready for fetching the
remote changes after merging the pull request (and running the Continuous
Integration pipeline)."

        push=
        [ "$1" = push ] && push=true
        if [ "$push" ]; then
            "$DOCKER_BASE"/check_git_clear.sh
        fi &&
            # The actual bump action.
            echo "DOCKER4GIS_VERSION=$(version)" >>.env &&
            if [ "$push" ]; then
                self git-push "$docker4gis-bump"
            fi
        ;;

    all)
        help "Run something in each sibling $docker4gis directory.
Usage: $docker4gis_command all EXECUTABLE [ARG...]
If \`$docker4gis_command\` should be executed, use \`self\` instead, e.g.
\`$docker4gis_command all self bump push\`"

        # Run the given command in all sibling docker4gis component directories,
        # including the current one.
        for dir in ../*; do
            # shellcheck source=/dev/null
            [ -e "$dir"/package.json ] &&
                [ -e "$dir"/.env ] &&
                DOCKER4GIS_VERSION= &&
                source "$dir"/.env &&
                [ "$DOCKER4GIS_VERSION" ] &&
                (
                    cd "$dir" || exit
                    echo
                    realpath .
                    # Run the given command.
                    "$@"
                )
        done
        ;;

    *)
        echo "Usage: $docker4gis_command init | component | build [COMPONENT] | run |"
        echo "  br [COMPONENT] | push [COMPONENT] | test [COMPONENT] | stop | geoserver |"
        echo "  base-component | template | alias [NAME] | $docker4gis | base |"
        echo "  login [PASSWORD] [USER] | version | bump [push] |"
        echo "  all EXECUTABLE|self [ARG...]"
        echo "For help: $docker4gis_command COMMAND help, or $docker4gis_command help COMMAND"
        echo "For debugging (tracing all shell commands):"
        echo "  $docker4gis_command trace COMMAND [ARG...]"
        echo "  output is saved in $log_path"
        ;;
    esac
} |& tee "$log"
