#!/bin/bash

# Uncomment for debugging the commands that are issued:
# echo
# echo " -- docker4gis $* --"
# echo
# set -x

action=$1
shift 1

export MSYS_NO_PATHCONV=1
docker4gis=$(basename "$0")

INSTALLED=
dg_dir=$(dirname "$0")
if [ "$(basename "$dg_dir")" = '.bin' ]; then
    INSTALLED=true
    dg_dir="$dg_dir"/../$docker4gis
fi
dg_dir=$(realpath "$dg_dir")
DOCKER_BASE="$dg_dir"/base

pipeline() {
    local main=$1

    # Init version file as well.
    [ -f package.json ] || echo '{
  "version": "0.0.0"
}' >package.json

    write() {
        echo "$2" >>"$1"
    }

    init() {
        local file=$1
        local trigger=$main
        local pr=none
        [ "$file" = "$build_validation" ] && {
            trigger=none
            pr=$main
        }
        echo -n '' >"$file"
        write "$file" "trigger:
- $trigger

pr:
- $pr

pool:
  vmImage: ubuntu-latest

steps:"
    }

    login() {
        echo "- script: |
    echo '\$(DOCKER_PASSWORD)' | docker login -u=$DOCKER_USER --password-stdin $DOCKER_REGISTRY
  displayName: 'docker login'"
    }

    local build_validation=azure-pipeline-build-validation.yml
    init "$build_validation"
    [ "$action" = init ] && write "$build_validation" "$(login)
"
    write "$build_validation" "- script: |
    npx --yes docker4gis@latest build
  displayName: 'docker4gis build'"

    local continuous_integration=azure-pipeline-continuous-integration.yml
    init "$continuous_integration"
    write "$continuous_integration" "- checkout: self
  persistCredentials: 'true'
  clean: 'true'

$(login)

- script: |
    git config --global user.email 'pipeline@azure.com'
    git config --global user.name 'Azure Pipeline'
  displayName: 'git config'

- script: |
    git checkout -b $main
    git push --set-upstream origin $main
  displayName: 'git undo detached state'
  
- script: |
    npx --yes docker4gis@latest push
  displayName: 'docker4gis push'"
}

version() {
    node --print "require('$DOCKER_BASE/../package.json').version"
}

case "$action" in

docker4gis)
    echo docker4gis
    ;;

base)
    echo "$DOCKER_BASE"
    ;;

version)
    version
    ;;

bump)
    echo "DOCKER4GIS_VERSION=$(version)" >>.env
    ;;

init)
    DOCKER_REGISTRY=$1
    DOCKER_USER=$2

    [ "$DOCKER_REGISTRY" ] && shift 1
    [ "$DOCKER_REGISTRY" ] || read -rp "Enter the Docker registry (default is the Docker Hub; enter m for docker.merkator.com : " DOCKER_REGISTRY
    [ "$DOCKER_REGISTRY" = 'm' ] && DOCKER_REGISTRY=docker.merkator.com
    [ "$DOCKER_REGISTRY" ] || DOCKER_REGISTRY=docker.io

    [ "$DOCKER_USER" ] && shift 1
    suggestion=$(basename "$(realpath ..)")
    [ "$DOCKER_USER" ] || read -rp "Enter the application's name (the \"user\" in the Docker registry; default is $suggestion) : " DOCKER_USER
    [ "$DOCKER_USER" ] || DOCKER_USER="$suggestion"

    echo "DOCKER4GIS_VERSION=$(version)
DOCKER_REGISTRY=$DOCKER_REGISTRY
DOCKER_USER=$DOCKER_USER
DOCKER_REPO=package
DEBUG=false
PROXY_HOST=
PROXY_PORT=
PROXY_PORT_HTTP=
SECRET=
API=
AUTH_PATH=
APP=
HOMEDEST=
POSTGRES_LOG_STATEMENT=
# POSTGRES_LOG_STATEMENT=ddl
# POSTGRES_LOG_STATEMENT=all
POSTFIX_DESTINATION=
POSTFIX_DOMAIN=" >>.env

    cp -r "$DOCKER_BASE"/package/template/* .
    mkdir -p components
    echo "$DOCKER_USER".log >>.gitignore

    pipeline main
    bash -i "$0" alias TEST
    ;;

component | base-component)
    if [ "$action" = base-component ]; then
        # We are a generic docker4gis base component.
        repo=$1
        [ "$repo" ] || read -rp "Enter the base component's name (the \"repo\" in the Docker registry) : " repo
        [ "$repo" ] || exit 1
        DOCKER4GIS_VERSION=$(version)
        DOCKER_REGISTRY=docker.io
        DOCKER_USER=docker4gis

        cp -r "$DOCKER_BASE"/template/* .
    else
        # We are a concrete application's component.
        for env_file in ../*/.env; do
            [ -f "$env_file" ] || break
            # shellcheck source=/dev/null
            . "$env_file"
            if [ "$DOCKER4GIS_VERSION" ] && [ "$DOCKER_REGISTRY" ] && [ "$DOCKER_USER" ]; then
                inited=true
                break
            fi
        done

        [ "$inited" ] || {
            echo "Package directory not foud; to create one, run $docker4gis init."
            exit 1
        }

        [ "$1" ] || interactive=true
        repo=$1
        component=$2
        tag=$3
        template=$4

        suggestion=$(basename "$(realpath "$PWD")")
        # up until first . character, if any (to support forked repos named
        # component.name.surname)
        suggestion=${suggestion%%.*}
        [ "$repo" ] || read -rp "Enter this repo's name (default is $suggestion) : " repo
        [ "$repo" ] || repo=$suggestion

        [ "$component" ] || read -rp "Enter the $docker4gis base image name, e.g. proxy, or postgis : " component
        [ "$component" ] || exit 1

        [ "$interactive" ] && {
            [ "$tag" ] || read -rp "Enter the base image's tag to use (default is latest) : " tag
        }
        [ "$tag" ] || tag=latest

        image=docker4gis/$component:$tag
        docker image pull "$image" >/dev/null || {
            echo "Image not found: $image"
            exit 1
        }
        container=$(docker container create "$image")

        docker container cp "$container":/template . || {
            echo "$image doesn't seem a $docker4gis component"
            exit 1
        }
        docker container rm "$container" >/dev/null
        if ! [ "$template" ]; then
            default=./template/.default
            if [ -f "$default" ]; then
                default=$(cat "$default")
                template=$default
                [ "$interactive" ] && {
                    choices=$(ls ./template)
                    choices=$(echo "$choices" | xargs)
                    read -rp "Enter the template name (one of: $choices - default is $default) : " template
                    [ "$template" ] || template=$default
                    ls ./template/"$template" >/dev/null 2>&1 || {
                        echo "Template not found: $template"
                        exit 1
                    }
                }
            fi
        fi
        cp -r ./template/"$template"/* .
        rm -rf ./template
    fi

    echo "DOCKER4GIS_VERSION=$DOCKER4GIS_VERSION
DOCKER_REGISTRY=$DOCKER_REGISTRY
DOCKER_USER=$DOCKER_USER
DOCKER_REPO=$repo" >>.env

    pipeline main
    ;;

build | run | br | push | test | stop | geoserver)
    # Export all variables in .env.
    set -a
    # shellcheck source=/dev/null
    . .env
    set +a

    [ "$DOCKER4GIS_VERSION" ] || {
        echo "Current directory not recognised as a docker4gis package or component."
        exit 1
    }

    # If not running an unpublished, local, in-development version of
    # docker4gis, switch to the version that the component scripts are
    # expecting. Otherwise, ignore the component's current DOCKER4GIS_VERSION,
    # and use the in-development version to see its effects.
    [ "$INSTALLED" ] && DOCKER_BASE=$(npx --yes "$docker4gis"@"$DOCKER4GIS_VERSION" base)

    "$DOCKER_BASE/main.sh" . "$action" "$@"
    ;;

alias)
    # https://serverfault.com/a/146747
    [[ $- == *i* ]] && interactive=true
    [ "$interactive" ] || {
        # rerun this action with bash in interactive mode, so that aliases are
        # loaded
        bash -i "$0" alias "$@"
        exit 0
    }

    command="npx --yes $docker4gis@latest"

    test=$1
    [ "$test" = 'TEST' ] && {
        shift 1
        if [ "$(dg docker4gis 2>/dev/null)" = 'docker4gis' ]; then
            exit 0
        else
            answer=
            read -rp "Create an alias for \`$command\`? [Yn] " answer
            [ "$answer" ] || answer=y
            if ! [ "$answer" = 'y' ] && ! [ "$answer" = 'Y' ]; then
                exit 0
            fi
        fi
    }

    name=$1

    [ "$name" ] || read -rp "Enter the name for the alias (default is dg) : " name
    [ "$name" ] || name=dg

    command_type=$(type -t "$name" 2>/dev/null) && {
        if [ "$command_type" = "alias" ] && [ "$($name docker4gis)" = 'docker4gis' ]; then
            : # This name was already an alias for docker4gis; nothing to do.
        else
            echo "$name is occupied; choose another name"
            "$0" alias
        fi
        exit
    }

    echo "alias $name='$command'" >>~/.bashrc
    # shellcheck source=/dev/null
    . ~/.bashrc
    ;;

*)
    echo "Usage: $docker4gis init | component | build | run | br | push | test | stop | geoserver | base-component | docker4gis | base | version | bump"
    ;;
esac
