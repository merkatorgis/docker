#!/bin/bash

export MSYS_NO_PATHCONV=1
docker4gis=$(basename "$0")
log_path=$docker4gis.log
version_development=development

# Trace/debug log.
if [ "$1" = trace ]; then
    shift 1
    export DOCKER4GIS_TRACE=true
    # Tee all stdout & stderr to a log file (from
    # https://superuser.com/a/212436/462952).
    exec > >(tee "$log_path") 2>&1
    # Trace all shell commands.
    set -x
    export SHELLOPTS
fi

# Set the action variable.
action=$1
shift 1

default_docker4gis_command="npx --yes $docker4gis@latest"
DOCKER4GIS_COMMAND=${DOCKER4GIS_COMMAND:-${ALIAS_NAME:-$default_docker4gis_command}}
export DOCKER4GIS_COMMAND

# Set the INSTALLED variable.
INSTALLED=
dg_dir=$(dirname "$0")
if [ "$(basename "$dg_dir")" = '.bin' ]; then
    INSTALLED=true
    dg_dir="$dg_dir"/../$docker4gis
fi
dg_dir=$(realpath "$dg_dir")

# Set the DOCKER_BASE variable (leading to main.sh, amongst others).
DOCKER_BASE="$dg_dir"/base

# Facilitate running npm dependencies.
if if [ "$INSTALLED" ]; then
    node_modules=$dg_dir/..
else
    node_modules=$dg_dir/node_modules
    # Install the git clone if it wasn't already.
    [ -d "$node_modules" ] || (
        cd "$dg_dir" &&
            npm install
    )
fi &&
    node_modules=$(realpath "$node_modules") &&
    [ -d "$node_modules" ] &&
    [ "$(basename "$node_modules")" = node_modules ]; then
    # Export the paths to npm dependencies.
    export BATS=$node_modules/.bin/bats
else
    echo "node_modules directory not found - $node_modules" >&2
    exit 1
fi

package_json() {
    [ -f package.json ] || echo '{
  "version": "0.0.0"
}' >package.json
    echo '*.log' >>.gitignore
}

pipeline() {
    local main=main

    local is_package
    [ "$action" = init ] && is_package=true

    local docker_login_command="echo '\$(DOCKER_PASSWORD)' | docker login -u=$DOCKER_USER --password-stdin $DOCKER_REGISTRY"

    local steps

    write() {
        # Either $build_validation or $continuous_integration.
        local file=$1

        # write - 1. Initialise variables.

        local trigger=none
        local pr=$main
        local stage=pr_stage
        local stage_display_name='Pull Request stage'
        local job=pr_job
        local job_display_name='Pull Request job'
        local login_steps=""

        [ "$file" = "$continuous_integration" ] && {
            trigger=$main
            pr=none
            stage=ci_stage
            stage_display_name='Continuous Integration stage'
            job=ci_job
            job_display_name='Continuous Integration job'
            if [ "$action" = base-component ]; then
                # We're on GitHub, in a docker4gis base component's repo.
                local git_repo
                git_repo=$(basename "$(realpath .)")
                login_steps="- bash: |
    git remote set-url origin https://merkatorgis:\$(GITHUB_PASSWORD)@github.com/merkatorgis/$git_repo.git"
            else
                # We're on Azure DevOps, in a concrete application component's
                # git repo.
                login_steps="- checkout: self
  persistCredentials: true"
            fi
            login_steps+="
  displayName: Git login
  "
        }

        # The build of a Package image verifies that all component images are
        # available at the docker registry, for which it needs to log in. All
        # Continuous Integration pipelines need to log into the docker registry
        # for pushing the resulting new image version.
        if [ "$is_package" ] || [ "$file" = "$continuous_integration" ]; then
            [ "$login_steps" ] && login_steps+="
"
            login_steps+="- bash: |
    $docker_login_command
  displayName: Docker login
  "
        fi

        # write - 2. Collect and format the steps.

        # Prepend global steps with login_steps.
        local steps=$login_steps$steps

        # Prepend (local) steps with the correct number of spaces:
        steps=$(echo "$steps" | awk '{print "    " $0}')

        # write - 3. Write the pipeline file, with the formatted steps in a
        # first job of a first stage.

        echo "trigger:
- $trigger

pr:
- $pr

stages:
- stage: $stage
  displayName: $stage_display_name
  jobs:
  - job: $job
    displayName: $job_display_name
    steps:
$steps" >"$file"

        # write - End of function.
    }

    # pipeline - 1. Write the Build Validation pipeline.

    steps="
- bash: |
    $default_docker4gis_command build
  displayName: $docker4gis build"

    # For a package image, also run the application and any integration tests.
    [ "$is_package" ] && steps+="

- bash: |
    echo '' | $default_docker4gis_command run latest
  displayName: Run app and integration tests"

    # Write the file.
    local build_validation=azure-pipeline-build-validation.yml
    write "$build_validation"

    # pipeline - 2. Write the Continuous Integration pipeline.

    # Save the current steps.
    local build_steps=$steps

    steps="
- bash: |
    git config --global user.email 'pipeline@azure.com'
    git config --global user.name 'Azure Pipeline'
  displayName: Git config

- bash: |
    git checkout -b $main
    git push --set-upstream origin $main
  displayName: Git undo detached state
"

    # For a package image, build, run, and test as a validation for the push
    # action.
    [ "$is_package" ] && steps+="$build_steps
"

    # Bump, build, push, tag, and commit the new version.
    steps+="
- bash: |
    $default_docker4gis_command push
  displayName: $docker4gis push"

    # For a package image, set the DOCKER4GIS_VERSION variable for use in the
    # deployment stage.
    [ "$is_package" ] && steps+="

- bash: |
    DOCKER4GIS_VERSION=v\$(node --print \"require('./package.json').version\")
    echo \"##vso[task.setvariable variable=DOCKER4GIS_VERSION;isOutput=true]\$DOCKER4GIS_VERSION\"
  displayName: Set DOCKER4GIS_VERSION variable for deploy stage
  name: docker4gis_version_step"

    # Write the file.
    local continuous_integration=azure-pipeline-continuous-integration.yml
    write "$continuous_integration"

    # For a package image, append a (commented-out) stage with a job deploying
    # the new version to the TEST environment.
    [ "$is_package" ] && echo "
# Uncomment the deploy_stage to have the pipeline deploy automatically to the
# TEST environment. This depends on docker4gis_version_step in the preceding
# stage, AND on a Service Connection (of type \"SSH\") named TEST (see the
# \"sshEndpoint\" attribute) being configured in the Project. Note that the inline
# script must not write anything to stderr, or the pipeline will fail (hence the
# \"2>&1\" at the end of certain lines).
# - stage: deploy_stage
#   displayName: Deploy stage
#   # Maybe you need to set up a custom pool, with an agent that runs from a
#   # location that is whitelisted in your target servers' firewalls.
#   # pool: VPN Agent
#   jobs:
#   - deployment: deploy_job
#     displayName: Deploy job
#     environment: TEST
#     variables:
#       DOCKER4GIS_VERSION: \$[ stageDependencies.ci_stage.ci_job.outputs['docker4gis_version_step.DOCKER4GIS_VERSION'] ]
#     strategy:
#       runOnce:
#         deploy:
#           steps:
#           - task: SSH@0
#             inputs:
#               sshEndpoint: TEST
#               runOptions: inline
#               inline: |
#                 # Log into the Docker registry.
#                 $docker_login_command 2>&1 &&
#                     # Go to the application's directory.
#                     cd /opt/docker4gis/$DOCKER_USER &&
#                     # Log at what time the pipeline started deploying which version.
#                     echo -n \"\$(date -Iseconds) \$(DOCKER4GIS_VERSION) \" >> pipeline.log &&
#                     # Start the new version of the application.
#                     echo '' | ./$DOCKER_USER.TEST \"\$(DOCKER4GIS_VERSION)\" 2>&1 &&
#                     # Log result code.
#                     echo \"\$?\" >> pipeline.log
#               readyTimeout: 20000" >>"$continuous_integration"
    # pipeline - End of function.
}

version() {
    local local=$1
    if [ "$local" = local ]; then
        dotenv &&
            echo "$DOCKER4GIS_VERSION"
    else
        local pipeline=$1
        if [ "$INSTALLED" ] || [ "$pipeline" = pipeline ]; then
            node --print "require('$DOCKER_BASE/../package.json').version"
        else
            echo "$version_development"
        fi
    fi
}

dotenv() {
    local flag=$1
    local file=${2:-.env}

    DOCKER4GIS_VERSION=

    if [ -e "$file" ]; then
        [ "$flag" = 'export' ] && set -a
        # shellcheck source=/dev/null
        source "$file"
        [ "$flag" = 'export' ] && set +a
    fi

    if [ "$DOCKER4GIS_VERSION" ] && [ -e "$file" ] && [ -e "$(dirname "$file")"/package.json ]; then
        true
    elif [ "$flag" = 'forgiving' ]; then
        false
    else
        echo "Current directory not recognised as a $docker4gis component or application package." >&2
        exit 1
    fi
}

assert_docker4gis_directory() {
    dotenv
}

# shellcheck disable=SC2317  # It's correct that the function is never called in this script.
self() {
    # Command given to the "all" action may use `self` to run docker4gis actions.
    "$0" "$@"
}

just_help=
[ "$1" = help ] && just_help=true
[ "$action" = help ] && {
    just_help=true
    action=$1
    shift 1
}
help() {
    [ "$just_help" ] || return 0
    local help_text=$1
    echo "$help_text"
    exit
}

remote_branch_name_available() {
    local new_branch=$1
    remote_branch_info=$(git ls-remote --heads origin refs/heads/"$new_branch") &&
        if [ "$remote_branch_info" ]; then
            echo "Error: remote branch exists: $new_branch" >&2
            false
        fi
}

case "$action" in

init)
    help "Initialise a new $docker4gis application in the current directory.
Do this somewhere where you can later create sibbling directories for the
application's components (using \`$DOCKER4GIS_COMMAND component\`)."

    DOCKER_REGISTRY=$1
    DOCKER_USER=$2

    [ "$DOCKER_REGISTRY" ] && shift 1
    [ "$DOCKER_REGISTRY" ] || read -rp \
        "Enter the Docker registry (default is the Docker Hub; enter m for docker.merkator.com) : " \
        DOCKER_REGISTRY
    [ "$DOCKER_REGISTRY" = 'm' ] && DOCKER_REGISTRY=docker.merkator.com
    [ "$DOCKER_REGISTRY" ] || DOCKER_REGISTRY=docker.io

    [ "$DOCKER_USER" ] && shift 1
    suggestion=$(basename "$(realpath ..)")
    [ "$DOCKER_USER" ] || read -rp \
        "Enter the application's name (the \"user\" in the Docker registry; default is $suggestion) : " \
        DOCKER_USER
    [ "$DOCKER_USER" ] || DOCKER_USER="$suggestion"

    echo "DOCKER4GIS_VERSION=$(version)
DOCKER_REGISTRY=$DOCKER_REGISTRY
DOCKER_USER=$DOCKER_USER
DOCKER_REPO=package
DEBUG=false
PROXY_HOST=
PROXY_PORT=
PROXY_PORT_HTTP=
API=
AUTH_PATH=
APP=
HOMEDEST=
TZ=
PGHOST=
PGHOSTADDR=
PGPORT=
PGDATABASE=
PGUSER=
PGPASSWORD=
POSTGRES_LOG_STATEMENT=
# POSTGRES_LOG_STATEMENT=ddl
# POSTGRES_LOG_STATEMENT=all
MYSQL_HOST=
MYSQL_DATABASE=
MYSQL_ROOT_PASSWORD=
POSTFIX_DESTINATION=
POSTFIX_DOMAIN=" >>.env

    mkdir -p components
    echo "$DOCKER_USER".log >>.gitignore

    package_json
    pipeline
    [ "$ALIAS_NAME" ] || bash -i "$0" alias TEST
    ;;

component | base-component | template)
    [ "$action" = component ] && help "Initialise a new $docker4gis application component in the current directory.
Do this in a sibling directory of your application directory (where you ran
\`$DOCKER4GIS_COMMAND init\`)."

    [ "$action" = base-component ] && help "Initialise a new $docker4gis base component in the current directory.
Base components are the repositories in https://hub.docker.com/u/$docker4gis.
This action will render a skeleton that you can build upon. Get in touch with
to discuss publication."

    [ "$action" = template ] && help "When developing a $docker4gis base component, scaffold a client application in
the current directory, so that you can try your new base component. When you're
happy, you can copy the contents into the 'template' directory of your base
component."

    write_dotenv() {
        echo "DOCKER4GIS_VERSION=$DOCKER4GIS_VERSION
DOCKER_REGISTRY=$DOCKER_REGISTRY
DOCKER_USER=$DOCKER_USER
DOCKER_REPO=$repo" >>.env
    }

    replace_component() {
        search='{{COMPONENT}}'
        replace=$repo
        find . -type f -exec sed -i "s|$search|$replace|ig" {} \;
    }

    finish() {
        local message=${1:-"$action initialised ✅"}
        local code=${2:-0}
        echo "$message"
        exit "$code"
    }

    error() {
        local message=${1:-error}
        local code=${2:-1}
        finish "$message" "$code"
    }

    package_json

    suggestion=$(basename "$(realpath "$PWD")")
    # Without a possible `docker4gis-` prefix.
    suggestion=${suggestion#"$docker4gis"-}
    # Up until a possible first `.` character (to support forked repos named
    # component.name.surname).
    suggestion=${suggestion%%.*}

    [ "$action" = base-component ] && {
        # Creating a generic docker4gis base component.
        repo=$1
        [ "$repo" ] || read -rp \
            "Enter the base component's name (the \"repository\" in the Docker registry; default is $suggestion) : " \
            repo
        [ "$repo" ] || repo=$suggestion
        DOCKER4GIS_VERSION=$(version)
        DOCKER_REGISTRY=docker.io
        DOCKER_USER=$docker4gis

        cp -r "$DOCKER_BASE"/template/. .
        replace_component

        write_dotenv
        pipeline
        # And we're done!
        finish
    }

    # Creating a concrete application's component.

    # Test if inited by finding package directory.
    for env_file in ../*/.env; do
        # Break when there's none.
        [ -f "$env_file" ] || break
        DOCKER_REPO=
        DOCKER4GIS_VERSION=
        DOCKER_REGISTRY=
        DOCKER_USER=
        dotenv forgiving "$env_file"
        if [ "$DOCKER_REPO" = package ] && [ "$DOCKER4GIS_VERSION" ] && [ "$DOCKER_REGISTRY" ] && [ "$DOCKER_USER" ]; then
            inited=true
            break
        fi
    done

    [ "$inited" ] ||
        error "Package directory not foud; to create one, run $DOCKER4GIS_COMMAND init. Or did
you mean base-component?"

    [ "$1" ] || interactive=true
    repo=$1
    component=$2
    tag=$3
    template=$4

    [ "$repo" ] || read -rp \
        "Name the new component (default is $suggestion) : " repo
    [ "$repo" ] || repo=$suggestion

    write_dotenv

    suggestion=$repo
    [ "$repo" = api ] && suggestion=postgrest
    [ "$repo" = app ] && suggestion=angular
    component_question="Which $docker4gis base image to extend? e.g. proxy, or postgis (default is $suggestion"
    [ "$action" = template ] || component_question="$component_question, n for none"

    [ "$component" ] || read -rp \
        "$component_question) : " \
        component
    [ "$component" ] || component=$suggestion

    [ "$action" = template ] && {
        # Just scaffolding an inital setup for developing a template for a new
        # base component.
        cp -r "$DOCKER_BASE"/template/template/. .
    }

    [ "$component" = n ] && {
        # Creating a component _not_ extending a docker4gis base component.
        cp -r "$DOCKER_BASE"/template/. .
        rm -rf template
        pipeline
    }

    [ "$action" = template ] || [ "$component" = n ] && {
        replace_component
        # And we're done!
        finish
    }

    # Creating a component extending a docker4gis base component.

    pipeline

    [ "$interactive" ] && {
        [ "$tag" ] || read -rp \
            "Which base image tag to use? (default is latest) : " tag
    }
    [ "$tag" ] || tag=latest

    image=$docker4gis/$component:$tag
    docker image pull "$image" ||
        error "Image not found: $image"

    container=$(docker container create "$image") ||
        error "Failed to create container from image $image"

    docker container cp "$container":/template . ||
        error "$image doesn't seem a $docker4gis component"

    docker container rm "$container" >/dev/null
    if ! [ "$template" ]; then
        # Test if there are multiple templates, by checking the existence of the
        # '.default' file.
        default=./template/.default
        if [ -f "$default" ]; then
            default=$(cat "$default")
            # Override the default template if there's a template named just
            # like the repo itself.
            [ -d "./template/$repo" ] && default=$repo
            template=$default
            [ "$interactive" ] && {
                choices=$(ls ./template)
                choices=$(echo "$choices" | xargs)
                read -rp \
                    "Enter the template name (one of: $choices - default is $default) : " \
                    template
                [ "$template" ] || template=$default
                ls ./template/"$template" >/dev/null 2>&1 ||
                    error "Template not found: $template"
            }
        fi
    fi
    cp -r ./template/"$template"/. .
    rm -rf ./template
    finish
    ;;

build | b | run | r | br | push | p | test | t | unbuild | stop | geoserver)
    [ "$action" = build ] || [ "$action" = b ] && help "Build a new image for the application component in the current directory.
Or pass the name of a sibling directory to build that component there.

For components other than the 'package' component, any/all (unit) tests are run
before the build starts, and the build is cancelled if any test fails (see
\`$DOCKER4GIS_COMMAND help test\`.)"

    [ "$action" = run ] || [ "$action" = r ] && help "Run the application.

If a newer version of a component is found in a sibling component directory, the
'package' component's directory is updated to run that newer version.
If a 'latest' version of a component image is found locally, and the version
in the component's package.json isn't newer than the version that is registered
in the 'package' directory, then that 'latest' component version
is run.

After all components' containers are started, any/all (integration) tests are
run (see \`$DOCKER4GIS_COMMAND help test\`.)"

    [ "$action" = br ] && help "First build, then run.
Can also \`$DOCKER4GIS_COMMAND $action [COMPONENT]\` from a sibling directory."

    [ "$action" = push ] || [ "$action" = p ] && help "Increment the component's version, build its image, push it to the Docker
registry, commit and push git changes.
Note that ideally, this is run by the Continuous Integration pipeline. If
that's configured, refrain from running \`$DOCKER4GIS_COMMAND $action\` by hand."

    [ "$action" = test ] || [ "$action" = t ] && help "Run the component's tests.
First, any files named 'test.sh' in the component's directory (and below) are
run. Exit from a test.sh with a non-zero code to indicate failure. Call the
exported function abort_tests to prevent running any further tests.

Then, any files named '*.bats' in the component's directory (and below) are run
using the [bash automated testing system](https://www.npmjs.com/package/bats).

If run with the optional FILE parameter, only the tests in that file are run. It
should be a .bats file, or an executable .sh file.

On \`$DOCKER4GIS_COMMAND build\`, all tests (considered to be 'unit tests') are
run before starting the build. If any test fails, the build is cancelled.
This is true for pipelines as well. Should a test depend on any external
package, amend the pipelines to install it, or include it as an [npm]
(https://www.npmjs.com/) dependency.

An exception is the 'package' component. Here, test are considered 'integration
tests', and they're not run before the \`$DOCKER4GIS_COMMAND build\`, but after
the \`$DOCKER4GIS_COMMAND run\`. So when these tests run, all the components'
containers have been started, and you can verify their interacting together.
Note that \`$DOCKER4GIS_COMMAND run\` is only done in the development
environment; not on any server where the application is deployed (though it can
be imagined as part of some future test-deploy pipeline)."

    [ "$action" = unbuild ] && help "Remove the local 'latest' version of the component's image.
Can also \`$DOCKER4GIS_COMMAND $action [COMPONENT]\` from a sibling directory."

    [ "$action" = stop ] && help "Stop the application's containers.
Except the proxy container, since that may still serve other applications."

    [ "$action" = geoserver ] && help "Copy the GeoServer configuration files out of the running $DOCKER_USER-geoserver
container, to the geoserver component repository in the current directory."

    # For application components, load the package component's environment
    # values. For base components (build), there's no package component, and
    # nothing happens here.
    for env_file in ../*/.env; do
        # Break when there's none.
        [ -f "$env_file" ] || break
        dotenv forgiving "$env_file"
        if [ "$DOCKER_REPO" = package ]; then
            dotenv export "$env_file"
            break
        fi
    done

    # Load the current component's own environment variables.
    dotenv export

    # If not running an unpublished, local, in-development version of
    # docker4gis, switch to the version that the component scripts are
    # expecting.
    if [ "$INSTALLED" ]; then
        [ "$DOCKER4GIS_TRACE" ] && echo "-- Switching to DOCKER4GIS_VERSION $DOCKER4GIS_VERSION."
        DOCKER_BASE=$( (
            # Prevent any trace output.
            set +x
            # Output this version's base directory.
            npx --yes "$docker4gis"@"$DOCKER4GIS_VERSION" base
        ))
    # Otherwise, ignore the component's current DOCKER4GIS_VERSION, and use
    # the new in-development version to see its effects.
    else
        export DOCKER4GIS_VERSION=$version_development
    fi

    [ "$action" = b ] && action=build
    [ "$action" = r ] && action=run
    [ "$action" = p ] && action=push
    [ "$action" = t ] && action='test'

    "$DOCKER_BASE/main.sh" . "$action" "$@"
    ;;

"$docker4gis")
    help "Just echo '$docker4gis' to indicate that this is that program."

    echo "$docker4gis"
    ;;

base)
    help "Echo the value of the DOCKER_BASE variable."

    echo "$DOCKER_BASE"
    ;;

version | v)
    help "Echo the $docker4gis version.
\`$DOCKER4GIS_COMMAND $action\` gives the version of that $docker4gis command
itself.
\`$DOCKER4GIS_COMMAND $action local\` gives the value of the
\$DOCKER4GIS_VERSION variable in the current $docker4gis component directory."

    version "$@"
    ;;

login)
    dotenv forgiving && {
        DOCKER_REGISTRY=" ($DOCKER_REGISTRY)"
        DOCKER_USER=" ($DOCKER_USER)"
    }
    help "Log into the DOCKER_REGISTRY$DOCKER_REGISTRY.
Usage: $DOCKER4GIS_COMMAND $action [PASSWORD] [USER].
Without PASSWORD, you'll be asked to type it.
Default USER is the DOCKER_USER value$DOCKER_USER."

    dotenv
    password=${1:?"password parameter not set"}
    user=${2:-$DOCKER_USER}
    echo "$password" | docker login -u "$user" --password-stdin "$DOCKER_REGISTRY"
    ;;

alias)
    help "Create a shell alias for \`$default_docker4gis_command\`.
Usage: $DOCKER4GIS_COMMAND $action [NAME]
Without NAME, you'll be asked to type one, or accept the default."

    # https://serverfault.com/a/146747
    [[ $- == *i* ]] && interactive=true
    [ "$interactive" ] || {
        # rerun this action with bash in interactive mode, so that aliases are
        # loaded
        bash -i "$0" alias "$@"
        exit 0
    }

    dg=dg

    test=$1
    [ "$test" = 'TEST' ] && {
        answer=
        read -rp "Create an alias for \`$default_docker4gis_command\`? [Yn] " answer
        [ "$answer" ] || answer=y
        if ! [ "$answer" = 'y' ] && ! [ "$answer" = 'Y' ]; then
            exit 0
        fi
    }

    name=$1

    [ "$name" ] || read -rp "Enter the name for the alias (default is $dg) : " name
    [ "$name" ] || name=$dg

    command_type=$(type -t "$name" 2>/dev/null) && {
        if [ "$command_type" = "alias" ] && [ "$($name "$docker4gis")" = "$docker4gis" ]; then
            : # This name was already an alias for docker4gis; nothing to do.
        else
            echo "$name is occupied; choose another name"
            "$0" alias
        fi
        exit
    }

    echo "alias $name='ALIAS_NAME=$name $default_docker4gis_command'" >>~/.bashrc

    shopt -s expand_aliases
    # shellcheck source=/dev/null
    . ~/.bashrc
    ;;

git-push | gp)
    default_new_branch=$docker4gis-changes
    help "Commit and push all changes to a remote branch.
Usage: $DOCKER4GIS_COMMAND $action [BRANCH_NAME].
The default BRANCH_NAME is $default_new_branch.
If more than one parameter is supplied, all parameters are joined with hyphens
(-) to form the BRANCH_NAME.
All changes are committed in git in a new branch, that is pushed to \`origin\`,
ready to create a pull request. Locally, the new branch is deleted after
switching back to the current branch, ready for fetching the remote changes
after merging the pull request (and running the Continuous Integration
pipeline, and syncing a forked repo)."

    [ "$(git status --short)" ] || {
        echo "No changes to commit."
        exit
    }
    new_branch=${*:-"$default_new_branch"}
    # Replace all spaces with hyphens.
    new_branch=${new_branch// /-}
    remote_branch_name_available "$new_branch" &&
        current_branch=$(git rev-parse --abbrev-ref HEAD) &&
        if [ "$current_branch" != "$new_branch" ]; then
            # This will fail if a branch with that name already exists.
            # Which is good, since it'd be acceptable when we're already
            # _on_ the new_branch, but not when we're on another branch and
            # the new_branch is just existing.
            git switch --create "$new_branch"
        fi &&
        git add --all &&
        git commit --message="$new_branch" &&
        git push --set-upstream origin "$new_branch" &&
        git switch "$current_branch" &&
        git branch --delete "$new_branch" &&
        echo "-> Remote branch $new_branch ready for pull request; the local branch is deleted."
    ;;

bump)
    help "In the current directory's component, bump $docker4gis to the latest version ($(version)).
Usage: $DOCKER4GIS_COMMAND $action [push|gp].
With \`push\` (or \`gp\`), the change is committed in git in a new branch, that 
is pushed to \`origin\`, ready to create a pull request. Locally, the new branch
is deleted after switching back to the current branch, ready for fetching the
remote changes after merging the pull request (and running the Continuous
Integration pipeline, and syncing a forked repo)."

    assert_docker4gis_directory

    if [ "$1" = push ] || [ "$1" = gp ]; then
        bump_branch=$docker4gis-bump
        "$DOCKER_BASE"/check_git_clear.sh &&
            remote_branch_name_available "$bump_branch"
    fi &&
        # The actual bump action.
        echo "DOCKER4GIS_VERSION=$(version)" >>.env &&
        version &&
        if [ "$bump_branch" ]; then
            self git-push "$bump_branch"
        fi
    ;;

all)
    help "Run something in each sibling $docker4gis directory.
Usage: $DOCKER4GIS_COMMAND $action EXECUTABLE [ARG...]
If \`$DOCKER4GIS_COMMAND\` should be executed, use \`self\` instead, e.g.
\`$DOCKER4GIS_COMMAND $action self bump push\`"

    # Run the given command in all sibling docker4gis component directories,
    # including the current one.
    for dir in ../*; do
        # Test if this is a docker4gis component directory.
        if (
            cd "$dir" || exit
            dotenv forgiving || exit
            echo
            realpath .
        ); then
            # Now run the given command in that docker4gis component directory.
            (
                cd "$dir" || exit
                "$@"
            ) || error=true
            # Record that we ran the command for at least one docker4gis
            # component (note that we couldn't do this assignment from inside a
            # subshell, which is why we have two steps for "check" and "run").
            any=true
        fi
    done
    # Reflect that we ran something, and that every run was successful.
    [ "$any" ] && ! [ "$error" ]
    ;;

bats)
    default_file=./test.bats
    help "Create a new file in the current directory, that calls the generic bats helper
($DOCKER_BASE/.plugins/bats/helper.bash).
Usage: $DOCKER4GIS_COMMAND $action [FILE]
The deault FILE is $default_file."

    file=${1:-$default_file}
    if [ -e "$file" ]; then
        echo "$file already exists."
        exit 1
    fi
    echo "load ~/.bats/helper.bash

function setup_file() {
    helper
}

" >"$file"
    ;;

*)
    echo "Manage $docker4gis applications and their components and base components."
    echo "Usage: $DOCKER4GIS_COMMAND init | component | build|b [COMPONENT] | run|r |"
    echo "  br [COMPONENT] | push|p [COMPONENT] | test|t [FILE] | unbuild [COMPONENT] |"
    echo "  stop | geoserver |  base-component | template | alias [NAME] | $docker4gis |"
    echo "  base | login [PASSWORD] [USER] | version|v [local] | bump [push] |"
    echo "  git-push|gp [BRANCH_NAME...] | bats | all EXECUTABLE|self [ARG...]"
    echo "Note that build, run, br, push, test, stop, unbuild, and geoserver run with the"
    echo "  $docker4gis version of DOCKER4GIS_VERSION from the current directory's .env."
    echo "For help: $DOCKER4GIS_COMMAND COMMAND help, or $DOCKER4GIS_COMMAND help COMMAND."
    echo "For debugging (tracing all shell commands):"
    echo "  $DOCKER4GIS_COMMAND trace COMMAND [ARG...]"
    echo "  output is saved in $log_path."
    ;;
esac
