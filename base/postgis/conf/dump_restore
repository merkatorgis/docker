#!/bin/bash

database=$POSTGRES_DB
if [ "$1" = '-d' ]; then
    database=$2
    shift 2
fi

dir=/fileport/$DOCKER_USER
mkdir -p "$dir"

dump=$dir/$database
roles=$dump.roles
backup=$dump.backup
lst=$backup.lst

tag() {
    for f in "$roles" "$backup" "$lst"; do
        [ -f "$f" ] &&
            mv "$f" "$f.$(date -I'seconds')"
    done
}

# create a new dump, while online
dump() {

    # save app.jwt_secret and any other settings passed as an argument, to get
    # set again as part of the restore
    settings="
        -- if we're upgrading, we're in default read-only mode
        start transaction read write;
        
        drop function if exists __restore_settings;
        create function __restore_settings()
        returns void language plpgsql as \$body\$ begin
    "
    for setting in app.jwt_secret "$@"; do
        value=$(pg.sh -Atc "select current_setting('$setting', true)")
        settings+="alter database $database set $setting to '$value';"
    done
    settings+="
        -- clean up after ourselves
        drop function __restore_settings;
        end \$body\$;
        commit;
    "
    psql -U "$POSTGRES_USER" -c "$settings" "$database"

    # tag any existing dump files, so that we won't overwrite them
    tag

    # save roles (they're not included in pg_dump's backup file)
    pg_dumpall -U "$POSTGRES_USER" --roles-only >"$roles"

    # backup database
    # https://postgis.net/docs/manual-dev/postgis_administration.html#hard_upgrade
    pg_dump -U "$POSTGRES_USER" -Fc -b -v -f "$backup" "$database"

    # we don't need this in the database anymore; it just needed to be included
    # in the dump
    psql -U "$POSTGRES_USER" -c "
        start transaction read write;
        drop function if exists __restore_settings;
        commit;
    " "$database"
}

# possibly restore an existing dump in an unprovisioned database, returning 0
# (true) if restored, or 1 (false) if not
restore() {

    restored=false

    if ! psql -U "$POSTGRES_USER" -c "select current_setting('app.provisioned')" "$database" &&
        [ -f "$roles" ] &&
        [ -f "$backup" ]; then

        restored=true

        # first restore the roles (which are not included in the backup file)
        psql -U "$POSTGRES_USER" -f "$roles" "$database"

        # prevent "schema already exists" errors
        psql -U "$POSTGRES_USER" -c "drop schema if exists tiger_data cascade" "$database"
        psql -U "$POSTGRES_USER" -c "drop schema if exists tiger cascade" "$database"

        # restore from the backup file
        # https://postgis.net/docs/manual-dev/postgis_administration.html#hard_upgrade
        postgis_restore_pl=$(find / -name postgis_restore.pl 2>/dev/null)
        echo "Restoring '$backup' using '$postgis_restore_pl';"
        echo "errors are saved in '/restore.err'."
        perl "$postgis_restore_pl" "$backup" |
            psql -U "$POSTGRES_USER" "$database" 2>/restore.err
        cat /restore.err

        psql -U "$POSTGRES_USER" -Atc "select __restore_settings()" "$database"

        # "it is wise to run ANALYZE after restoring from a dump file"
        # https://www.postgresql.org/docs/13/app-pgdump.html
        psql -U "$POSTGRES_USER" -c "analyze" "$database"

        # tag the current dump files as done
        tag
    fi

    # this setting is used in the test above (the value doesn't matter; it just
    # needs to be set) - it's set in all cases, since if we weren't restoring a
    # dump, we're expected to be provisioning the database from DDL instead
    psql -U "$POSTGRES_USER" -c "alter database $database set app.provisioned to true" "$database"

    # return true (0) or false (1)
    $restored
}

# render the database read-only, before creating a new dump - restore the dump
# in a new, empty database to get it writable again
upgrade() {

    psql -U "$POSTGRES_USER" -c "
        -- temporarily disallow new connections
        -- https://www.postgresql.org/docs/13/sql-alterdatabase.html
        alter database $database allow_connections false;

        -- make future connections read-only
        -- https://www.postgresql.org/docs/13/runtime-config-client.html
        alter database $database set default_transaction_read_only to on;

        -- terminate any (presumably writable) connections
        -- https://www.postgresql.org/docs/13/functions-admin.html
        -- https://www.postgresql.org/docs/13/monitoring-stats.html#MONITORING-PG-STAT-ACTIVITY-VIEW
        select pg_terminate_backend(pid) from pg_stat_activity where datname = '$database';

        -- reallow new (read-only) connections
        alter database $database allow_connections true;
    " postgres # connect to NOT the database at hand

    dump "$@"

    echo >&2
    echo "NOTICE: since an 'upgrade' dump was created, database $database is now read-only" >&2
}

# dump or restore or upgrade (see Dockerfile)
action=$(basename "$0")
$action "$@"
