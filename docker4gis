#!/bin/bash

action=$1
shift 1

export MSYS_NO_PATHCONV=1
docker4gis=$(basename "$0")

INSTALLED=
DOCKER4GIS_HOME=$(dirname "$0")
if [ "$(basename "$DOCKER4GIS_HOME")" = '.bin' ]; then
    INSTALLED=true
    DOCKER4GIS_HOME="$DOCKER4GIS_HOME"/../$docker4gis
fi
DOCKER4GIS_HOME=$(realpath "$DOCKER4GIS_HOME")
DOCKER_BASE="$DOCKER4GIS_HOME"/base

pipeline() {
    main=$1

    write() {
        echo "$2" >>"$1"
    }

    init() {
        echo -n "" >"$1"
        write "$1" "trigger:
- $2

pool:
  vmImage: ubuntu-latest

steps:"
    }

    build() {
        write "$1" "- script: docker login -u=$DOCKER_USER -p='\$(DOCKER_PASSWORD)' $DOCKER_REGISTRY
  displayName: 'docker login'

- script: npx --yes docker4gis@latest build
  displayName: 'docker4gis build'"
    }

    build_validation=azure-pipeline-build-validation.yml
    init "$build_validation" none
    build "$build_validation"

    continuous_integration=azure-pipeline-continuous-integration.yml
    init "$continuous_integration" "$main"
    write "$continuous_integration" "- checkout: self
  persistCredentials: 'true'
  clean: 'true'
"
    build "$continuous_integration"
    write "$continuous_integration" "
- script: |
    git config --global user.email 'pipeline@azure.com'
    git config --global user.name 'Azure Pipeline'
  displayName: 'git config'

- script: |
    git checkout -b $main
    git push --set-upstream origin $main
  displayName: 'git undo detached state'
  
- script: npx --yes docker4gis@latest push
  displayName: 'docker4gis push'"
}

version() {
    node -pe "require('$DOCKER4GIS_HOME/package.json').version"
}

case "$action" in

docker4gis)
    echo docker4gis
    ;;

base)
    echo "$DOCKER_BASE"
    ;;

version)
    version
    ;;

upgrade)
    echo "DOCKER4GIS_VERSION=$(version)" >>.env
    ;;

init)
    if [ "$1" = 'base' ]; then
        # We are a generic docker4gis base component.
        shift 1
        DOCKER_REPO=$1
        DOCKER_REGISTRY=${2:-docker.io}
        DOCKER_USER=${3:-docker4gis}

        [ "$DOCKER_REPO" ] || read -rp "Enter the base component's name (the \"repo\" in the Docker registry) : " DOCKER_REPO
        [ "$DOCKER_REPO" ] || exit 1

        echo "DOCKER4GIS_VERSION=$(version)
DOCKER_REGISTRY=$DOCKER_REGISTRY
DOCKER_USER=$DOCKER_USER
DOCKER_REPO=$DOCKER_REPO" >>.env
    else
        # We are e concrete application's component or package.
        DOCKER_REGISTRY=$1
        DOCKER_USER=$2

        [ "$DOCKER_REGISTRY" ] && shift 1
        [ "$DOCKER_REGISTRY" ] || read -rp "Enter the Docker registry (default is the Docker Hub; enter m for docker.merkator.com : " DOCKER_REGISTRY
        [ "$DOCKER_REGISTRY" = 'm' ] && DOCKER_REGISTRY=docker.merkator.com
        [ "$DOCKER_REGISTRY" ] || DOCKER_REGISTRY=docker.io

        [ "$DOCKER_USER" ] && shift 1
        suggestion=$(basename "$(realpath ..)")
        [ "$DOCKER_USER" ] || read -rp "Enter the application's name (the \"user\" in the Docker registry; default is $suggestion) : " DOCKER_USER
        [ "$DOCKER_USER" ] || DOCKER_USER="$suggestion"

        echo "DOCKER4GIS_VERSION=$(version)
DOCKER_REGISTRY=$DOCKER_REGISTRY
DOCKER_USER=$DOCKER_USER
DOCKER_REPO=package
DEBUG=false
PROXY_HOST=
PROXY_PORT=
PROXY_PORT_HTTP=
SECRET=
API=
AUTH_PATH=
APP=
HOMEDEST=
POSTGRES_LOG_STATEMENT=
# POSTGRES_LOG_STATEMENT=ddl
# POSTGRES_LOG_STATEMENT=all
POSTFIX_DESTINATION=
POSTFIX_DOMAIN=" >>.env

        cp -r "$DOCKER4GIS_HOME"/base/package/template/* .
        mkdir -p components
    fi

    pipeline main
    bash -i "$0" alias TEST
    ;;

component)
    for env_file in ../*/.env; do
        [ -f "$env_file" ] || break
        # shellcheck source=/dev/null
        . "$env_file"
        if [ "$DOCKER4GIS_VERSION" ] && [ "$DOCKER_REGISTRY" ] && [ "$DOCKER_USER" ]; then
            inited=true
            break
        fi
    done

    [ "$inited" ] || {
        echo "Package directory not foud; to create one, run $docker4gis init."
        exit 1
    }

    [ "$1" ] || interactive=true
    repo=$1
    component=$2
    tag=$3
    template=$4

    suggestion=$(basename "$(realpath "$PWD")")
    # up until first . character, if any (to support forked repos named
    # component.name.surname)
    suggestion=${suggestion%%.*}
    [ "$repo" ] || read -rp "Enter this repo's name (default is $suggestion) : " repo
    [ "$repo" ] || repo=$suggestion

    [ "$component" ] || read -rp "Enter the $docker4gis base image name, e.g. proxy, or postgis : " component
    [ "$component" ] || exit 1

    [ "$interactive" ] && {
        [ "$tag" ] || read -rp "Enter the base image's tag to use (default is latest) : " tag
    }
    [ "$tag" ] || tag=latest

    image=docker4gis/$component:$tag
    docker image pull "$image" >/dev/null || {
        echo "Image not found: $image"
        exit 1
    }
    container=$(docker container create "$image")

    docker container cp "$container":/template . || {
        echo "$image doesn't seem a $docker4gis component"
        exit 1
    }
    docker container rm "$container" >/dev/null
    if ! [ "$template" ]; then
        default=./template/.default
        if [ -f "$default" ]; then
            default=$(cat "$default")
            template=$default
            [ "$interactive" ] && {
                choices=$(ls ./template)
                choices=$(echo "$choices" | xargs)
                read -rp "Enter the template name (one of: $choices - default is $default) : " template
                [ "$template" ] || template=$default
                ls ./template/"$template" >/dev/null 2>&1 || {
                    echo "Template not found: $template"
                    exit 1
                }
            }
        fi
    fi
    cp -r ./template/"$template"/* .
    rm -rf ./template

    echo "DOCKER4GIS_VERSION=$DOCKER4GIS_VERSION
DOCKER_REGISTRY=$DOCKER_REGISTRY
DOCKER_USER=$DOCKER_USER
DOCKER_REPO=$repo" >>.env

    pipeline main
    ;;

build | run | br | push | test | stop | geoserver)
    set -a
    # shellcheck source=/dev/null
    . .env
    set +a

    [ "$DOCKER4GIS_VERSION" ] || {
        echo "Current directory not recognised as a docker4gis package or component."
        exit 1
    }

    # use the docker4gis version that the component scripts are expecting
    [ "$INSTALLED" ] && DOCKER_BASE=$(npx --yes "$docker4gis"@"$DOCKER4GIS_VERSION" base)

    "$DOCKER_BASE/main.sh" . "$action" "$@"
    ;;

alias)
    # https://serverfault.com/a/146747
    [[ $- == *i* ]] && interactive=true
    [ "$interactive" ] || {
        # rerun this action with bash in interactive mode, so that aliases are
        # loaded
        bash -i "$0" alias "$@"
        exit 0
    }

    command="npx --yes $docker4gis@latest"

    test=$1
    [ "$test" = 'TEST' ] && {
        shift 1
        if [ "$(dg docker4gis 2>/dev/null)" = 'docker4gis' ]; then
            exit 0
        else
            answer=
            read -rp "Create an alias for \`$command\`? [Yn] " answer
            [ "$answer" ] || answer=y
            if ! [ "$answer" = 'y' ] && ! [ "$answer" = 'Y' ]; then
                exit 0
            fi
        fi
    }

    name=$1

    [ "$name" ] || read -rp "Enter the name for the alias (default is dg) : " name
    [ "$name" ] || name=dg

    command_type=$(type -t "$name" 2>/dev/null) && {
        if [ "$command_type" = "alias" ] && [ "$($name docker4gis)" = 'docker4gis' ]; then
            # this name was already an alias for docker4gis
            exit 0
        fi
        echo "$name is occupied; choose another name"
        exit 1
    }

    echo "alias $name='$command'" >>~/.bashrc
    # shellcheck source=/dev/null
    . ~/.bashrc
    ;;

*)
    echo "Usage: $docker4gis init | component | build | run | br | push | test | stop | geoserver | init base | docker4gis | base | version | upgrade"
    ;;
esac
