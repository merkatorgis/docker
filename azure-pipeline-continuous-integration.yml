trigger:
# "npm-package" -> "master" after merge
- npm-package

pr:
- none

pool:
  vmImage: ubuntu-latest

steps:
- checkout: self
  persistCredentials: 'true'
  clean: 'true'

- script: docker login -u=docker4gis -p='$(DOCKER_PASSWORD)' docker.io
  displayName: 'docker login'

- script: |
    git config --global user.email 'pipeline@azure.com'
    git config --global user.name 'Azure Pipeline'
  displayName: 'git config'

# "npm-package" -> "master" (2x) after merge
- script: |
    git checkout -b npm-package
    git push --set-upstream origin npm-package
  displayName: 'git undo detached state'

# Increment version in package.json, git commit, and git tag; see
# https://docs.npmjs.com/cli/v9/commands/npm-version. We don't actually do
# semantic versioning; we just keep incrementing the PATCH version (see
# https://semver.org).
- script: |
    npm version patch --message '%s [skip ci]'
    version=$(./docker4gis version)
    cd base/package
    ../../docker4gis upgrade
    ../upgrade_templates.sh "$version" package
    git add .
    git commit -m "$version [skip ci]"
  displayName: 'bump package version'

- script: |
    cd base/package
    DOCKER_BASE=..
    ./build.sh
  displayName: 'build package image'
  
- script: |
    version=$(./docker4gis version)
    image=docker4gis/package
    latest=$image:latest
    image=$image:$version
    docker image tag "$latest" "$image"
    docker image push "$image"
  displayName: 'push package image'

# Publish to npm, using the environment variable placeholder in .npmrc; see
# https://docs.npmjs.com/using-private-packages-in-a-ci-cd-workflow#create-and-check-in-a-project-specific-npmrc-file.
- script: npm publish
  displayName: 'npm publish'
  env:
    NPM_TOKEN: $(NPM_TOKEN)

# Push npm version's and our changes back to the original repo.
- script: |
    git push
    git push --tags
  displayName: 'git push version'
