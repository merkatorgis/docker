#!/bin/bash

database=$POSTGRES_DB
if [ "$1" = '-d' ]; then
    database=$2
    shift 2
fi

dir=/fileport/$DOCKER_USER
mkdir -p "$dir"

dump=$dir/$database
roles=$dump.roles
backup=$dump.backup
lst=$backup.lst

tag() {
    for f in "$roles" "$backup" "$lst"; do
        [ -f "$f" ] &&
            mv "$f" "$f.$(date -I'seconds')"
    done
}

# create a new dump
dump() {
    # tag any existing dump files, so that we won't overwrite them
    tag

    # save app.jwt_secret and any other settings passed as an argument, to get
    # set again as part of the resore
    settings="
        drop function if exists __restore_settings;
        create function __restore_settings()
        returns void language plpgsql as \$body\$ begin
    "
    for setting in app.jwt_secret "$@"; do
        value=$(pg.sh -Atc "select current_setting('$setting', true)")
        settings="$settings
            alter database $database set $setting to '$value';
        "
    done
    settings="$settings
        drop function __restore_settings;
        end \$body\$
    "
    psql -U "$POSTGRES_USER" -c "$settings" "$database"

    # save roles (which aren't included in pg_dump's backup file)
    pg_dumpall -U "$POSTGRES_USER" --roles-only >"$roles"

    # backup database, cf
    # https://postgis.net/docs/manual-dev/postgis_administration.html#hard_upgrade
    pg_dump -U "$POSTGRES_USER" -Fc -b -v -f "$backup" "$database"
}

# possibly restore an existing dump in an unconfigured database, returning 0
# (true) if restored, or 1 (false) if not
restore() {
    restored=false
    if ! psql -U "$POSTGRES_USER" -c "select current_setting('app.configured')" "$database" &&
        [ -f "$roles" ] &&
        [ -f "$backup" ]; then
        restored=true

        # first restore the roles (which are not included in the backup file)
        psql -U "$POSTGRES_USER" -f "$dump.roles" "$database"

        # prevent "schema already exists" errors
        psql -U "$POSTGRES_USER" -c "drop schema if exists tiger_data cascade" "$database"
        psql -U "$POSTGRES_USER" -c "drop schema if exists tiger cascade" "$database"

        # restore from the backup file, cf
        # https://postgis.net/docs/manual-dev/postgis_administration.html#hard_upgrade
        postgis_restore_pl=$(find / -name postgis_restore.pl 2>/dev/null)
        perl "$postgis_restore_pl" "$dump.backup" |
            psql -U "$POSTGRES_USER" "$database" 2>/restore.err
        cat /restore.err

        psql -U "$POSTGRES_USER" -Atc "select __restore_settings()" "$database"

        # "it is wise to run ANALYZE after restoring from a dump file", cf
        # https://www.postgresql.org/docs/13/app-pgdump.html
        psql -U "$POSTGRES_USER" -c "analyze" "$database"

        # tag the current dump files as done
        tag
    fi
    # this setting is used in the test above (the value doesn't matter; it just
    # needs to be set) - it's set in all cases, since if we weren't restoring a
    # dump, we're expected to be configuring the database from DDL instead
    psql -U "$POSTGRES_USER" -c "alter database $database set app.configured to true" "$database"
    # return true (0) or false (1)
    $restored
}

# dump or restore
action=$(basename "$0")
"$action"
