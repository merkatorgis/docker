#!/bin/bash

database=$POSTGRES_DB
[ "$1" = '-d' ] && database=$2 && shift 2

dir=/fileport/$DOCKER_USER
mkdir -p "$dir"

dump=$dir/$database
roles=$dump.roles
backup=$dump.backup
lst=$backup.lst

tag() {
    for f in "$roles" "$backup" "$lst"; do
        [ -f "$f" ] &&
            mv "$f" "$f.$(date -I'seconds')"
    done
}

sql() {
    local dbname=$database
    [ "$1" = "-d" ] && dbname=$2 && shift 2
    run() {
        # use --no-align and --tuples-only to return an proper, unformatted
        # value that can be used in conditional statements
        psql -U "$POSTGRES_USER" -d "$dbname" --no-align --tuples-only "$@"
    }
    local input=$1
    if [ "$input" ]; then
        if [ -f "$input" ]; then
            # read from given file
            run -f "$input"
        else
            # execute given sql command
            run -c "$input"
        fi
    else
        # read from stdin
        run
    fi
}

# create a new dump, while online
dump() {

    # save app.jwt_secret and any other settings passed as an argument, to get
    # set again as part of the restore
    local settings="
        -- if we're upgrading, we're in default read-only mode
        start transaction read write;

        drop function if exists __restore_settings;
        create function __restore_settings()
        returns void language plpgsql as \$body\$ begin
    "
    local value
    for setting in app.jwt_secret "$@"; do
        value=$(sql "select current_setting('$setting', true)")
        settings+="alter database $database set $setting to '$value';"
    done
    settings+="
        -- clean up after ourselves
        drop function __restore_settings;
        end \$body\$;
        commit;
    "
    sql "$settings"

    # tag any existing dump files, so that we won't overwrite them
    tag

    # save roles (they're not included in pg_dump's backup file)
    pg_dumpall -U "$POSTGRES_USER" --roles-only >"$roles"

    # backup database
    # https://postgis.net/docs/manual-dev/postgis_administration.html#hard_upgrade
    pg_dump -U "$POSTGRES_USER" -Fc -b -v -f "$backup" "$database"

    # we don't need this in the database anymore; it just needed to be included
    # in the dump
    sql "
        start transaction read write;
        drop function if exists __restore_settings;
        commit;
    "
}

# possibly restore an existing dump in an unprovisioned database, returning 0
# (true) if restored, or 1 (false) if not
restore() {

    local restored=false

    do_restore() {
        restored=true

        # first restore the roles (which are not included in the backup file)
        sql "$roles"

        # prevent "schema already exists" errors
        sql "drop schema if exists tiger_data cascade"
        sql "drop schema if exists tiger cascade"

        # restore from the backup file
        # https://postgis.net/docs/manual-dev/postgis_administration.html#hard_upgrade
        local postgis_restore_pl
        postgis_restore_pl=$(find / -name postgis_restore.pl 2>/dev/null)
        echo "Restoring using '$postgis_restore_pl'..."
        echo "  Saving errors in '/restore.err'..."
        perl "$postgis_restore_pl" "$backup" | sql 2>/restore.err
        echo "> Listing '/restore.err':"
        cat /restore.err
        echo "< Listing '/restore.err' finished"

        sql "select __restore_settings()"

        # "it is wise to run ANALYZE after restoring from a dump file"
        # https://www.postgresql.org/docs/13/app-pgdump.html
        sql "analyze"

        # tag the current dump files as done
        tag
    }

    local provisioned
    provisioned=$(sql "select current_setting('app.provisioned', true)")
    [ "$provisioned" != "true" ] && [ -f "$roles" ] && [ -f "$backup" ] && do_restore

    # this setting is used in the test above - it's set in all cases, since if
    # we weren't restoring a dump, we're expected to be provisioning the
    # database from DDL instead
    sql "alter database $database set app.provisioned to true"

    # return true (0) or false (1)
    $restored
}

# render the database read-only, before creating a new dump - restore the dump
# in a new, empty database to get it writable again
upgrade() {

    # connect to NOT the database at hand
    sql -d postgres "
        -- temporarily disallow new connections
        -- https://www.postgresql.org/docs/13/sql-alterdatabase.html
        alter database $database allow_connections false;

        -- make future connections read-only
        -- https://www.postgresql.org/docs/13/runtime-config-client.html
        alter database $database set default_transaction_read_only to on;

        -- terminate any (presumably writable) connections
        -- https://www.postgresql.org/docs/13/functions-admin.html
        -- https://www.postgresql.org/docs/13/monitoring-stats.html#MONITORING-PG-STAT-ACTIVITY-VIEW
        select pg_terminate_backend(pid) from pg_stat_activity where datname = '$database';

        -- reallow new (read-only) connections
        alter database $database allow_connections true;
    "

    dump "$@"

    echo >&2
    echo "NOTICE: since an 'upgrade' dump was created, database $database is now read-only..." >&2
    echo "  See https://github.com/merkatorgis/docker4gis/blob/master/docs/postgis.md#upgrade..." >&2
}

# dump or restore or upgrade (see Dockerfile)
action=$(basename "$0")
$action "$@"
